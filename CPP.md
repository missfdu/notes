## 静态成员

有些类的属性是全体对象共用，仅需要一份，不希望占用对象的数据空间，为了封装性又拒绝使用全局变量，C++为此提供了静态成员机制。

注意：C++类中的静态成员仍借用保留字`static`，但与之前的静态全局变量、静态局部变量和静态函数的概念无任何关联。

类体内声明静态成员加保留字`static`，类体外定义时不写`static`

访问方式：只认类型，不认对象

`对象名.静态数据成员名` `对象名.静态成员函数名(实参)` 或 更一般地 `类名::静态数据成员名``类名::静态成员函数名(实参)`

### 静态数据成员

类的静态数据成员存放于全局数据区，不占具体对象的数据空间。

静态数据成员的创建和销毁权不属于任何对象，对象有权利读写、更有义务维护静态数据成员，其改变可能影响该类的所有对象。

在创建具体对象时，应该可以访问到静态数据成员，这要求静态数据成员在创建类的任何对象之前就已存在，故其应该在主函数之前先行定义和初始化。

### 静态成员函数

静态函数不隐含与任何具体对象的联系，即不隐含传递“本对象地址”的指针形式参数`this`

## 友元

若对象带有大量数据，而访问数据时都通过专门的成员函数周转，则影响效率。故在保证数据安全的前提下适当开放数据的访问权限给指定的“朋友”，使其可直接访问类中受保护或私有的成员。

友元**不是类的成员**，仅仅是类的朋友，可分为友元函数和友元类。

### 友元函数

在类声明中，函数返回类型前使用保留字`friend`表示函数不是本类成员，而是本类的友元函数。

友元函数可在类体内声明并定义；也可在类体内声明后，在类体外定义(不可加`friend`，也不存在类名和作用域区分符`::`)

由于**类的友元函数不是该类的成员函数**，自然不默认联系具体的对象。友元函数访问类的具体对象及对象的成员时，应将对象(最好是其引用)作为实参**显式**地传递给友元函数。

### 友元类

声明一个类是另一个类的友元，成为友元类。友元类中所有成员均成为本类的友元函数，均能访问本类的所有成员。但友元类的友元函数不一定是本类的友元。

## 运算符重载

### 运算符概述

运算符是计算机程序设计语言中表达**数据加工操作**的符号，由语言本身规定其意义，由编译系统内部定义其基本功能。

C++中，可称运算符为**运算符函数**，即运算符是一种特殊的函数，其名称、定义和调用格式与普通函数有些差别。运算符函数可作为某个类的成员函数，也可作为普通函数(常作为类的友元函数)

### 重载运算符

C++规定如下：

- 不允许用户定义新的运算符
- 不允许重载下面5个运算符
  - `::`作用域区分符
  - `.`成员访问运算符
  - `.*`成员指针访问运算符
  - `sizeof`数据尺寸运算符
  - `?:`三目条件运算符
- 重载运算符时，至少要有一个操作数为用户自定义的类型
- 重载的运算符函数不能为类的静态成员函数

关于运算符重载，有如下基本原则：

- 形参尽可能为引用型(避免拷贝构造操作数)，尽可能加以`const`限制(保护实参操作数)
- 尽可能返回引用(避免拷贝构造临时对象，并使运算表达式成为左值)
- 若**第一个操作数可能为非本类对象**，必须将**操作符重载为类的友元函数**
- 尽可能使运算符保持原有含义和直观客观性
- 充分利用类型转换函数、转换构造函数

### 重载双目运算符

双目运算符需要两个操作数。由于类的成员函数隐含传递本对象的地址给`this`指针(运算符函数将实参对象兼容地处理成对象的地址)，故**双目运算符成员函数只有一个显式形参**。而作为友元的双目运算符函数应该有两个显式形参。

重载双目运算符时，应特别注意当两个操作数联系同一个实参对象时的处理，避免因修改左操作数(同时也是右操作数，即使右操作数有`const`限制)而“无意中”改变右操作数导致计算错误。

#### 重载算术运算符

算术运算中一般不应修改操作数，必须将运算结果存放在其他对象或变量中。这些运算符函数的返回类型只能为**值返回**。

#### 重载迭代赋值运算符

迭代赋值运算中一般不应修改右操作数，计算结果存入左操作数。因此这些运算符函数可以是成员函数(也可以是友元函数)，并且应设计成引用返回对象本身。

