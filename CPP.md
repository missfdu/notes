## 静态成员

有些类的属性是全体对象共用，仅需要一份，不希望占用对象的数据空间，为了封装性又拒绝使用全局变量，C++为此提供了静态成员机制。

注意：C++类中的静态成员仍借用保留字`static`，但与之前的静态全局变量、静态局部变量和静态函数的概念无任何关联。

类体内声明静态成员加保留字`static`，类体外定义时不写`static`

访问方式：只认类型，不认对象

`对象名.静态数据成员名` `对象名.静态成员函数名(实参)` 或 更一般地 `类名::静态数据成员名``类名::静态成员函数名(实参)`

### 静态数据成员

类的静态数据成员存放于全局数据区，不占具体对象的数据空间。

静态数据成员的创建和销毁权不属于任何对象，对象有权利读写、更有义务维护静态数据成员，其改变可能影响该类的所有对象。

在创建具体对象时，应该可以访问到静态数据成员，这要求静态数据成员在创建类的任何对象之前就已存在，故其应该在主函数之前先行定义和初始化。

### 静态成员函数

静态函数不隐含与任何具体对象的联系，即不隐含传递“本对象地址”的指针形式参数`this`

## 友元

若对象带有大量数据，而访问数据时都通过专门的成员函数周转，则影响效率。故在保证数据安全的前提下适当开放数据的访问权限给指定的“朋友”，使其可直接访问类中受保护或私有的成员。

友元**不是类的成员**，仅仅是类的朋友，可分为友元函数和友元类。

### 友元函数

在类声明中，函数返回类型前使用保留字`friend`表示函数不是本类成员，而是本类的友元函数。

友元函数可在类体内声明并定义；也可在类体内声明后，在类体外定义(不可加`friend`，也不存在类名和作用域区分符`::`)

由于**类的友元函数不是该类的成员函数**，自然不默认联系具体的对象。友元函数访问类的具体对象及对象的成员时，应将对象(最好是其引用)作为实参**显式**地传递给友元函数。

### 友元类

声明一个类是另一个类的友元，成为友元类。友元类中所有成员均成为本类的友元函数，均能访问本类的所有成员。但友元类的友元函数不一定是本类的友元。

